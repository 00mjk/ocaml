
#     module M1 : sig type 'a t val f : int t -> bool t end
#     module M2 : sig type 'a t = new int val f : int -> int val r : int ref end
#   module M3 : sig type 'a t val f : int t -> bool t end
#   Characters 52-54:
  module M4 : sig type 'a t  val r : int t ref end = M2;; (* should fail *)
                                                     ^^
Error: Signature mismatch:
       Modules do not match:
         sig type 'a t = new int val f : int -> int val r : int ref end
       is not included in
         sig type 'a t val r : int t ref end
       Values do not match:
         val r : int ref
       is not included in
         val r : int t ref
#     module M5 : sig type 'a t val f : int t -> bool t val r : int t ref end
#   module M6 : sig type 'a t = private int val f : int t -> bool t end
#     Characters 57-83:
    struct type 'a t = int end;;
    ^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: Signature mismatch:
       Modules do not match:
         sig type 'a t = int end
       is not included in
         sig type 'a t = new int end
       Type declarations do not match:
         type 'a t = int
       is not included in
         type 'a t = new int
       A private or new type would be made transparent.
#     module M8 : sig type 'a t val f : int t ref -> int end
#     Characters 61-108:
    struct type 'a t = new int  let f x = ref x end;; (* should be ok *)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: Signature mismatch:
       Modules do not match:
         sig type 'a t = new int val f : 'a -> 'a ref end
       is not included in
         sig type 'a t val f : int -> int t ref end
       Values do not match:
         val f : 'a -> 'a ref
       is not included in
         val f : int -> int t ref
#       module M : sig type t = new type u = new end
# type (_, _) comp = Eq : ('a, 'a) comp | Diff : ('a, 'b) comp
# - : (M.t, M.u) comp -> bool = <fun>
#     Characters 61-70:
  module M = struct type t = new T   type u = t = T end;; (* fail *)
                                          ^^^^^^^^^
Error: This variant or record definition does not match that of type t
       A private or new type would be made transparent.
#                       module M :
  sig
    type t = new
    type t' = new
    type u = new T
    type u' = new T
    type v = T
    type v' = T
    type v2 = V
    type z
    type z'
  end
# - : (M.t, M.t') comp -> bool = <fun>
# - : (M.t, M.u) comp -> bool = <fun>
# - : (M.t, M.v) comp -> bool = <fun>
# Characters 29-55:
  fun (x : (M.t,M.z) comp)  -> match x with Diff -> false;; (* warn *)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Eq
- : (M.t, M.z) comp -> bool = <fun>
# - : (M.u, M.u') comp -> bool = <fun>
# - : (M.u, M.v) comp -> bool = <fun>
# Characters 29-55:
  fun (x : (M.u,M.z) comp)  -> match x with Diff -> false;; (* warn *)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Eq
- : (M.u, M.z) comp -> bool = <fun>
# Characters 29-55:
  fun (x : (M.v,M.v') comp) -> match x with Diff -> false;; (* warn *)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Eq
- : (M.v, M.v') comp -> bool = <fun>
# - : (M.v, M.v2) comp -> bool = <fun>
# Characters 29-55:
  fun (x : (M.v,M.z) comp)  -> match x with Diff -> false;; (* warn *)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Eq
- : (M.v, M.z) comp -> bool = <fun>
# Characters 29-55:
  fun (x : (M.z,M.z') comp) -> match x with Diff -> false;; (* warn *)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Eq
- : (M.z, M.z') comp -> bool = <fun>
# 
