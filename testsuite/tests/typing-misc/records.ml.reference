
#   type t = { x : int; y : int; }
# Characters 5-6:
  {x=3;z=2};;
       ^
Error: Unbound record field label z
# Characters 9-10:
  fun {x=3;z=2} -> ();;
           ^
Error: Unbound record field label z
#     Characters 26-34:
  {x=3; contents=2};;
        ^^^^^^^^
Error: The record field label Pervasives.contents belongs to the type 
       'a ref but is mixed here with labels of type t
#     type u = private { mutable u : int; }
# Characters 0-5:
  {u=3};;
  ^^^^^
Error: Cannot create values of the private type u
# Characters 11-12:
  fun x -> x.u <- 3;;
             ^
Error: Cannot assign field u of the private type u
#         module M : sig type t = { x : int; y : int; } end
#   val f : M.t -> int = <fun>
# val r : M.t = {M.x = 1; y = 2}
# val z : int = 3
#     type t = { x : int; y : int; }
# type u = { x : bool; y : bool; }
#   val f : t -> int = <fun>
# val f : t -> int = <fun>
#       val f : t -> int = <fun>
#     Characters 44-45:
         {x; y} -> y + y;; (* fails *)
                   ^
Error: This expression has type bool but an expression was expected of type
         int
#       val f : t -> int = <fun>
#           module M : sig type t = { x : int; } type u = { x : bool; } end
# val f : M.t -> int = <fun>
# Characters 18-19:
  let f (r:M.t) = r.x;; (* warning *)
                    ^
Warning 40: x is used out of scope.
val f : M.t -> int = <fun>
#       module M : sig type t = { x : int; y : int; } end
#     module N : sig type u = { x : bool; y : bool; } end
# # # val f : M.t -> int = <fun>
#           module M :
  sig
    type t = { x : int; }
    module N : sig type s = t = { x : int; } end
    type u = { x : bool; }
  end
# # val f : M.t -> int = <fun>
#     type u = { x : bool; y : int; z : char; }
# type t = { x : int; y : bool; }
# - : u -> bool * char = <fun>
#   type u = { x : int; y : bool; }
# type t = { x : bool; y : int; z : char; }
# - : u = {x = 3; y = true}
#       type foo = { x : int; y : int; }
# type bar = { x : int; }
# Characters 20-21:
  let b : bar = {x=3; y=4};; (* fail but don't warn *)
                      ^
Error: The record field label y belongs to the type foo
       but is mixed here with labels of type bar
#   module M : sig type foo = { x : int; y : int; } end
# module N : sig type bar = { x : int; y : int; } end
# Characters 19-22:
  let r = { M.x = 3; N.y = 4; };; (* error: different definitions *)
                     ^^^
Error: The record field label N.y belongs to the type N.bar
       but is mixed here with labels of type M.foo
#     module MN :
  sig
    type foo = M.foo = { x : int; y : int; }
    type bar = N.bar = { x : int; y : int; }
  end
module NM :
  sig
    type bar = N.bar = { x : int; y : int; }
    type foo = M.foo = { x : int; y : int; }
  end
# Characters 19-23:
  let r = {MN.x = 3; NM.y = 4};; (* error: type would change with order *)
                     ^^^^
Error: The record field label NM.y belongs to the type NM.foo = M.foo
       but is mixed here with labels of type MN.bar = N.bar
# 
