
#   type t = { x : int; y : int; }
# Characters 5-6:
  {x=3;z=2};;
       ^
Error: This record has type t
       which does not include the label z
# Characters 9-10:
  fun {x=3;z=2} -> ();;
           ^
Error: This record has type t
       which does not include the label z
#     Characters 26-34:
  {x=3; contents=2};;
        ^^^^^^^^
Error: The record field label Pervasives.contents belongs to the type 
       'a ref but is mixed here with labels of type t
#     type u = private { mutable u : int; }
# Characters 0-5:
  {u=3};;
  ^^^^^
Error: Cannot create values of the private type u
# Characters 11-12:
  fun x -> x.u <- 3;;
             ^
Error: Cannot assign field u of the private type u
#         module M : sig type t = { x : int; y : int; } end
#   val f : M.t -> int = <fun>
# val r : M.t = {M.x = 1; y = 2}
# val z : int = 3
#         module M : sig type t = { x : int; y : int; } type u = { y : bool; } end
#   val f : M.t -> int = <fun>
# val r : M.t = {M.x = 1; y = 2}
#     val f : Complex.t -> float = <fun>
# Characters 32-36:
  let f x = ignore (x:Complex.t); x.re;; (* non principal *)
                                  ^^^^
Warning 18: this type-based field selection is not principal.
val f : Complex.t -> float = <fun>
#         module M :
  sig
    type t = { x : int; }
    module N : sig type s = t = { x : int; } end
    type u = { x : bool; }
  end
# val f : M.u -> bool = <fun>
# val f : M.t -> int = <fun>
# # val f : M.N.s -> int = <fun>
# val f : M.t -> int = <fun>
#   type u = { x : bool; y : int; z : char; }
# type t = { x : int; y : bool; }
# - : u -> char * bool = <fun>
# Characters 4-9:
  fun {x;z} -> x,z;; (* fails *)
      ^^^^^
Error: This pattern matches values of type u
       but a pattern was expected which matches values of type t
# - : u -> bool * char = <fun>
# - : u -> bool * char = <fun>
# Characters 36-41:
  fun r -> ignore (r:u); match r with {x;z} -> x,z;; (* fails for -principal *)
                                      ^^^^^
Error: This pattern matches values of type u
       but a pattern was expected which matches values of type t
# 
